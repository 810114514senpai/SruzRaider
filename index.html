<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sruz-Raider</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            background-image: url('https://cdn.discordapp.com/attachments/1379153981544333375/1379546528389267628/IMG5008.jpg?ex=6840a253&is=683f50d3&hm=4b726dc640d8900224277a6539b9b52e609ecf104e318219546abfc0e920fa69&');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            color: #eee;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* ç”»é¢ä¸Šéƒ¨ã«å¯„ã›ã‚‹ */
            min-height: 100vh;
            padding: 20px; /* å…¨ä½“ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’è¿½åŠ  */
            box-sizing: border-box;
        }
        .overlay {
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            max-width: 800px; /* æœ€å¤§å¹…ã‚’åºƒãã™ã‚‹ */
            width: 100%;
            box-sizing: border-box;
            margin-top: 20px; /* ä¸Šéƒ¨ã®ä½™ç™½ */
            margin-bottom: 20px; /* ä¸‹éƒ¨ã®ä½™ç™½ */
        }
        .container {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #00bfff;
            text-align: center;
            margin-bottom: 25px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #c0c0c0;
        }
        input[type="text"],
        textarea,
        select {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 20px;
            border: 1px solid #555;
            border-radius: 4px;
            box-sizing: border-box;
            background-color: #333;
            color: #eee;
        }
        textarea {
            resize: vertical;
            min-height: 80px;
        }
        .slider-group {
            margin-bottom: 20px;
        }
        .slider-group label {
            margin-bottom: 5px;
        }
        .slider-group input[type="range"] {
            width: calc(100% - 20px);
            margin-top: 5px;
            -webkit-appearance: none;
            height: 8px;
            background: #555;
            border-radius: 5px;
            outline: none;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00bfff;
            cursor: pointer;
            box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
        }
        .checkbox-group {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
        }
        .checkbox-group input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap; /* ãƒœã‚¿ãƒ³ãŒå¤šã™ãã‚‹å ´åˆã«æŠ˜ã‚Šè¿”ã™ */
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            flex-grow: 1; /* flex item ãŒå‡ç­‰ã«å¹…ã‚’å–ã‚‹ */
            min-width: 180px; /* ãƒœã‚¿ãƒ³ã®æœ€å°å¹… */
        }
        button:hover {
            background-color: #0056b3;
        }
        button#stopButton {
            background-color: #dc3545;
        }
        button#stopButton:hover {
            background-color: #c82333;
        }
        #status {
            margin-top: 25px;
            padding: 15px;
            border-radius: 5px;
            background-color: #222;
            color: #eee;
            border: 1px solid #444;
            word-wrap: break-word;
            white-space: pre-wrap;
        }
        .success {
            background-color: #28a745;
            color: white;
        }
        .error {
            background-color: #dc3545;
            color: white;
        }
        .rate-limited {
            background-color: #ffc107;
            color: #343a40;
        }
    </style>
</head>
<body>
    <div class="overlay">
        <div class="container">
            <h1>Sruz-Raider</h1>

            <label for="tokenInput">Discordãƒˆãƒ¼ã‚¯ãƒ³:</label>
            <textarea id="tokenInput" placeholder="Discordãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ”¹è¡ŒåŒºåˆ‡ã‚Šã§å…¥åŠ›"></textarea>

            <label for="channelIdInput">ãƒãƒ£ãƒ³ãƒãƒ«ID:</label>
            <textarea id="channelIdInput" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã™ã‚‹ãƒãƒ£ãƒ³ãƒãƒ«IDã‚’æ”¹è¡ŒåŒºåˆ‡ã‚Šã§å…¥åŠ›"></textarea>

            <hr>
            <h2>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡è¨­å®š</h2>
            <label for="messageInput">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸:</label>
            <textarea id="messageInput" placeholder="é€ä¿¡ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›"></textarea>

            <div class="slider-group">
                <label for="speedSlider">é€ä¿¡é€Ÿåº¦ (é–“éš”: <span id="speedValue">1000</span> ms) - å³ã«ã™ã‚‹ã¨é€Ÿããªã‚Šã¾ã™</label>
                <input type="range" id="speedSlider" min="100" max="10000" value="1000" oninput="document.getElementById('speedValue').textContent=this.value">
            </div>

            <div class="slider-group">
                <label for="countSlider">é€ä¿¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•° (ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ãƒ»ã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆ): <span id="countValue">1</span></label>
                <input type="range" id="countSlider" min="1" max="50" value="1" oninput="document.getElementById('countValue').textContent=this.value">
            </div>

            <div class="slider-group">
                <label for="mentionCountSlider">ãƒ©ãƒ³ãƒ€ãƒ ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ãƒ¦ãƒ¼ã‚¶ãƒ¼æ•°: <span id="mentionCountValue">0</span></label>
                <input type="range" id="mentionCountSlider" min="0" max="10" value="0" oninput="document.getElementById('mentionCountValue').textContent=this.value">
            </div>

            <label for="mentionIdsInput">ãƒ©ãƒ³ãƒ€ãƒ ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ç”¨ãƒ¦ãƒ¼ã‚¶ãƒ¼ID (ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š):</label>
            <input type="text" id="mentionIdsInput" placeholder="ä¾‹: 123456789012345678,987654321098765432">

            <div class="checkbox-group">
                <input type="checkbox" id="addRandomStringCheckbox" onchange="toggleRandomStringSlider()">
                <label for="addRandomStringCheckbox">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ãƒ©ãƒ³ãƒ€ãƒ ãªæ–‡å­—åˆ—ã‚’è¿½åŠ </label>
            </div>

            <div class="slider-group" id="randomStringLengthGroup" style="display: none;">
                <label for="randomStringLengthSlider">ãƒ©ãƒ³ãƒ€ãƒ æ–‡å­—åˆ—ã®é•·ã•: <span id="randomStringLengthValue">5</span></label>
                <input type="range" id="randomStringLengthSlider" min="1" max="20" value="5" oninput="document.getElementById('randomStringLengthValue').textContent=this.value">
            </div>

            <div class="checkbox-group">
                <input type="checkbox" id="enableReplyCheckbox" onchange="toggleReplyInput()">
                <label for="enableReplyCheckbox">æŒ‡å®šãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«è¿”ä¿¡ã™ã‚‹</label>
            </div>
            <div id="replyToMessageGroup" style="display: none;">
                <label for="replyToMessageIdInput">è¿”ä¿¡ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ID:</label>
                <input type="text" id="replyToMessageIdInput" placeholder="è¿”ä¿¡å…ˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸IDã‚’å…¥åŠ›">
            </div>

            <hr>
            <h2>ã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆè¨­å®š</h2>
            <div class="checkbox-group">
                <input type="checkbox" id="enableThreadCheckbox" onchange="toggleThreadOptions()">
                <label for="enableThreadCheckbox">ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½œæˆã™ã‚‹</label>
            </div>
            <div id="threadOptionsGroup" style="display: none;">
                <label for="threadNameInput">ã‚¹ãƒ¬ãƒƒãƒ‰å:</label>
                <input type="text" id="threadNameInput" placeholder="ä¾‹: ä»Šæ—¥ã®é›‘è«‡">
                <label for="threadTypeSelect">ã‚¹ãƒ¬ãƒƒãƒ‰ã‚¿ã‚¤ãƒ—:</label>
                <select id="threadTypeSelect">
                    <option value="public_thread">ãƒ‘ãƒ–ãƒªãƒƒã‚¯ã‚¹ãƒ¬ãƒƒãƒ‰</option>
                    <option value="private_thread">ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ (Nitroãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿)</option>
                </select>
            </div>

            <hr>
            <h2>ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ è¨­å®š</h2>
            <div class="checkbox-group">
                <input type="checkbox" id="enableReactionCheckbox" onchange="toggleReactionOptions()">
                <label for="enableReactionCheckbox">æŒ‡å®šãƒãƒ£ãƒ³ãƒãƒ«ã®**æ—¢å­˜ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸**ã«ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ã™ã‚‹</label>
            </div>
            <div id="reactionOptionsGroup" style="display: none;">
                <label for="reactionEmojisInput">ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³çµµæ–‡å­— (åŒºåˆ‡ã‚Šãªã—):</label>
                <input type="text" id="reactionEmojisInput" placeholder="ä¾‹: ğŸ˜‚ğŸ‘â¤ï¸ (ã‚«ã‚¹ã‚¿ãƒ çµµæ–‡å­—ã¯åå‰:IDå½¢å¼)">
                <div class="slider-group">
                    <label for="reactionMessageCountSlider">ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä»˜ã‘ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•° (æœ€æ–°ã‹ã‚‰éå»ã¸): <span id="reactionMessageCountValue">1</span></label>
                    <input type="range" id="reactionMessageCountSlider" min="1" max="50" value="1" oninput="document.getElementById('reactionMessageCountValue').textContent=this.value">
                </div>
            </div>

            <hr>

            <div class="button-group">
                <button onclick="startSending('message')">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚’é–‹å§‹</button>
                <button onclick="startSending('thread')">ã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆã‚’é–‹å§‹</button>
                <button onclick="startSending('reaction')">ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ ã‚’é–‹å§‹</button>
                <button id="stopButton" onclick="stopSending()" disabled>å…¨ã¦ã®æ“ä½œã‚’åœæ­¢</button>
            </div>

            <div id="status">ã“ã“ã«é€ä¿¡ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
        </div>
    </div>

    <script>
        let isSending = false;
        let stopRequested = false;
        let currentOperation = null; // 'message', 'thread', 'reaction'

        const allEmojis = [
            'ğŸ˜€', 'ğŸ˜ƒ', 'ğŸ˜„', 'ğŸ˜', 'ğŸ˜†', 'ğŸ˜…', 'ğŸ˜‚', 'ğŸ¤£', 'ğŸ˜Š', 'ğŸ˜‡', 'ğŸ™‚', 'ğŸ™ƒ', 'ğŸ˜‰', 'ğŸ˜Œ', 'ğŸ˜', 'ğŸ¥°', 'ğŸ˜˜', 'ğŸ˜—', 'ğŸ˜™', 'ğŸ˜š',
            'ğŸ˜‹', 'ğŸ˜›', 'ğŸ˜', 'ğŸ˜œ', 'ğŸ¤ª', 'ğŸ¤¨', 'ğŸ§', 'ğŸ¤“', 'ğŸ˜', 'ğŸ¤©', 'ğŸ¥³', 'ğŸ˜', 'ğŸ˜’', 'ğŸ˜', 'ğŸ˜”', 'ğŸ˜Ÿ', 'ğŸ˜•', 'ğŸ¥º', 'ğŸ˜¤', 'ğŸ˜ ',
            'ğŸ˜¡', 'ğŸ¤¬', 'ğŸ¤¯', 'ğŸ˜³', 'ğŸ¥µ', 'ğŸ¥¶', 'ğŸ˜±', 'ğŸ˜¨', 'ğŸ˜°', 'ğŸ˜¥', 'ğŸ˜¢', 'ğŸ˜­', 'ğŸ¤¥', 'ğŸ¤«', 'ğŸ¤­', 'ğŸ¤', 'ğŸ¤”', 'ğŸ¤¢', 'ğŸ¤®', 'ğŸ¤§', 'ğŸ˜·', 'ğŸ¤’', 'ğŸ¤•', 'ğŸ¤‘', 'ğŸ¤ ', 'ğŸ¥³', 'ğŸ˜', 'ğŸ¤“', 'ğŸ§', 'ğŸ¤¯', 'ğŸ¤«', 'ğŸ¤”', 'ğŸ¤¥', 'ğŸ˜¶', 'ğŸ˜', 'ğŸ˜‘', 'ğŸ˜¬', 'ğŸ™„',
            'ğŸ˜¤', 'ğŸ˜ ', 'ğŸ˜¡', 'ğŸ¤¬', 'ğŸ˜ˆ', 'ğŸ‘¿', 'ğŸ’€', 'â˜ ï¸', 'ğŸ’©', 'ğŸ¤¡', 'ğŸ‘¹', 'ğŸ‘º', 'ğŸ‘»', 'ğŸ‘½', 'ğŸ‘¾', 'ğŸ¤–', 'ğŸ˜º', 'ğŸ˜¸', 'ğŸ˜¹', 'ğŸ˜»',
            'ğŸ˜¼', 'ğŸ˜½', 'ğŸ™€', 'ğŸ˜¿', 'ğŸ˜¾', 'ğŸ‘‹', 'ğŸ¤š', 'ğŸ–ï¸', 'âœ‹', 'ğŸ––', 'ğŸ‘Œ', 'ğŸ¤', 'âœŒï¸', 'ğŸ¤', 'ğŸ¤™', 'ğŸ¤˜', 'ğŸ¤Ÿ', 'ğŸ‘', 'ğŸ™Œ', 'ğŸ‘',
            'ğŸ¤²', 'ğŸ¤', 'ğŸ™', 'âœï¸', 'ğŸ’…', 'ğŸ¤³', 'ğŸ’ª', 'ğŸ¦µ', 'ğŸ¦¶', 'ğŸ‘‚', 'ğŸ‘ƒ', 'ğŸ§ ', 'ğŸ«€', 'ğŸ«', 'ğŸ¦·', 'ğŸ¦´', 'ğŸ‘€', 'ğŸ‘ï¸', 'ğŸ‘…', 'ğŸ‘„',
            'ğŸ’‹', 'ğŸ©¸', 'ğŸ¦ ', 'ğŸ©»', 'ğŸ’‰', 'ğŸ’Š', 'ğŸ©¹', 'ğŸ©¼', 'ğŸ©±', 'ğŸ©²', 'ğŸ©³', 'ğŸ©´', 'ğŸ‘™', 'ğŸ‘š', 'ğŸ‘•', 'ğŸ‘–', 'ğŸ‘Ÿ', 'ğŸ‘', 'ğŸ‘ ', 'ğŸ‘¡',
            'ğŸ‘¢', 'ğŸ¥¿', 'ğŸ©°', 'ğŸ©', 'ğŸ‘‘', 'ğŸ‘’', 'ğŸ“', 'ğŸ§¢', 'ğŸ—ï¸', 'ğŸ½', 'ğŸ§£', 'ğŸ§¤', 'ğŸ§¥', 'ğŸ§¦', 'ğŸ‘—', 'ğŸ‘˜', 'ğŸ¥»', 'ğŸ©±', 'ğŸ©²', 'ğŸ©³',
            'ğŸ©´', 'ğŸ‘™', 'ğŸ’¼', 'ğŸ’', 'ğŸ‘œ', 'ğŸ‘›', 'ğŸ‘', 'ğŸ›ï¸', 'ğŸ›’', 'ğŸ', 'ğŸ€', 'ğŸˆ', 'ğŸ‰', 'ğŸŠ', 'ğŸ‹', 'ğŸ', 'ğŸ', 'ğŸ', 'ğŸ', 'ğŸ‘',
            'ğŸ§§', 'ğŸ‡', 'ğŸ†', 'âœ¨', 'ğŸ’«', 'ğŸŒŸ', 'âš¡', 'ğŸ”¥', 'ğŸ’¥', 'â˜„ï¸', 'â˜€ï¸', 'ğŸŒ', 'ğŸŒ›', 'ğŸŒœ', 'ğŸŒ‘', 'ğŸŒ“', 'ğŸŒ”', 'ğŸŒ•', 'ğŸŒ–',
            'ğŸŒ—', 'ğŸŒ˜', 'ğŸŒ™', 'ğŸŒ', 'ğŸŒ', 'ğŸŒ', 'ğŸŒ', 'ğŸ—ºï¸', 'ğŸ—¾', 'ğŸ§­', 'ğŸ”ï¸', 'â›°ï¸', 'ğŸŒ‹', 'ğŸ—»', 'ğŸ•ï¸', 'ğŸ–ï¸', 'ğŸœï¸', 'ğŸï¸', 'ğŸï¸', 'ğŸ›£ï¸',
            'ğŸ›¤ï¸', 'ğŸŒ‰', 'ğŸŒƒ', 'ğŸŒŒ', 'ğŸŒ ', 'ğŸš—', 'ğŸš•', 'ğŸš™', 'ğŸšŒ', 'ğŸš', 'ğŸï¸', 'ğŸï¸', 'ğŸ›µ', 'ğŸš²', 'ğŸ›´',
            'ğŸš“', 'ğŸš‘', 'ğŸš’', 'ğŸš', 'ğŸšš', 'ğŸš›', 'ğŸš¢', 'ğŸ›¥ï¸', 'ğŸš¤',
            'ğŸ›¶', 'â›µ', 'ğŸ›³ï¸', 'âœˆï¸', 'ğŸš', 'ğŸš‚', 'ğŸšƒ', 'ğŸš„', 'ğŸš…', 'ğŸš†',
            'ğŸš‡', 'ğŸšˆ', 'ğŸš‰', 'ğŸšŠ', 'ğŸš', 'ğŸš ', 'ğŸš¡', 'ğŸšŸ', 'ğŸš¥', 'ğŸš¦',
            'ğŸš§', 'ğŸš¨', 'ğŸ­', 'ğŸ›ï¸', 'ğŸ¤', 'ğŸ¥', 'ğŸ¦', 'ğŸ¨', 'ğŸ©',
            'ğŸª', 'ğŸ«', 'ğŸ¬', 'ğŸ¯', 'ğŸ°', 'ğŸ’’', 'ğŸ—¼', 'ğŸ—½', 'â›ª', 'ğŸ•Œ',
            'ğŸ•', 'ğŸ•‹', 'â›©ï¸', 'ğŸŒ', 'â›²', 'â›º', 'ğŸŒ', 'ğŸŒƒ', 'âœ¨', 'â˜ï¸', 'ğŸŒ¤ï¸', 'â›ˆï¸', 'ğŸŒˆ', 'ğŸŒ‰', 'ğŸŒ‹', 'ğŸŒŒ',
            'ğŸŒŠ', 'ğŸˆ', 'ğŸ•', 'ğŸ', 'ğŸ¹', 'ğŸ‡', 'ğŸ¦Š', 'ğŸ»', 'ğŸ¼', 'ğŸ¨', 'ğŸ…', 'ğŸ¦', 'ğŸ„', 'ğŸ–', 'ğŸ—',
            'ğŸ’', 'ğŸ¦', ' orangutan', 'ğŸ”', 'ğŸ§', 'ğŸ¦', 'ğŸ¥', 'ğŸ£', 'ğŸ¦…', 'ğŸ¦†', 'ğŸ¦¢',
            'ğŸ¦‰', 'ğŸ¦‡', 'ğŸº', 'ğŸ—', 'ğŸ', 'ğŸ¦„', 'ğŸ', 'ğŸ›', 'ğŸ¦‹', 'ğŸŒ', 'ğŸ', 'ğŸœ', 'ğŸ¦Ÿ',
            'ğŸ¦—', 'ğŸ•·ï¸', 'ğŸ¦‚', 'ğŸ¢', 'ğŸ', 'ğŸ¦', 'ğŸ¦–', 'ğŸ¦•', 'ğŸ™', 'ğŸ¦‘', 'ğŸ¦', 'ğŸ¦',
            'ğŸ¦€', 'ğŸ¡', 'ğŸ ', 'ğŸŸ', 'ğŸ¬', 'ğŸ³', 'ğŸ¦ˆ', 'ğŸŠ', 'ğŸ†', 'ğŸ¦“', 'ğŸ¦˜',
            'ğŸ¦¡', 'ğŸ¦¦', 'ğŸ¦”', 'ğŸ¦¨', 'ğŸ¦', 'ğŸ¦™', 'ğŸ¦›', 'ğŸ¦œ', 'ğŸ¦š', 'ğŸ¦©', 'ğŸ¦¥', 'ğŸ¦§',
            'ğŸ¦¨', 'ğŸ¦¡', 'ğŸ¦¦', 'ğŸ¦”', 'ğŸ¦¨', 'ğŸ¦', 'ğŸ¦™', 'ğŸ¦›', 'ğŸ¦œ', 'ğŸ¦š', 'ğŸ¦©', 'ğŸ¦¥', 'ğŸ¦§'
        ];

        function generateRandomString(length) {
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return result;
        }

        function getRandomEmoji() {
            return allEmojis[Math.floor(Math.random() * allEmojis.length)];
        }

        function toggleRandomStringSlider() {
            const checkbox = document.getElementById('addRandomStringCheckbox');
            const sliderGroup = document.getElementById('randomStringLengthGroup');
            if (checkbox.checked) {
                sliderGroup.style.display = 'block';
            } else {
                sliderGroup.style.display = 'none';
            }
        }

        function toggleReplyInput() {
            const checkbox = document.getElementById('enableReplyCheckbox');
            const replyGroup = document.getElementById('replyToMessageGroup');
            if (checkbox.checked) {
                replyGroup.style.display = 'block';
            } else {
                replyGroup.style.display = 'none';
            }
        }

        function toggleThreadOptions() {
            const checkbox = document.getElementById('enableThreadCheckbox');
            const threadGroup = document.getElementById('threadOptionsGroup');
            if (checkbox.checked) {
                threadGroup.style.display = 'block';
            } else {
                threadGroup.style.display = 'none';
            }
        }

        function toggleReactionOptions() {
            const checkbox = document.getElementById('enableReactionCheckbox');
            const reactionGroup = document.getElementById('reactionOptionsGroup');
            if (checkbox.checked) {
                reactionGroup.style.display = 'block';
            } else {
                reactionGroup.style.display = 'none';
            }
        }

        function stopSending() {
            stopRequested = true;
            document.getElementById('status').textContent += "\n\n--- æ“ä½œåœæ­¢ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ä¿¡ã—ã¾ã—ãŸã€‚ç¾åœ¨ã®å‡¦ç†ãŒå®Œäº†æ¬¡ç¬¬åœæ­¢ã—ã¾ã™ã€‚ ---";
            document.querySelectorAll('.button-group button').forEach(button => {
                if (button.id !== 'stopButton') {
                    button.disabled = false;
                }
            });
            document.getElementById('stopButton').disabled = true;
        }

        async function startSending(operationType) {
            if (isSending) {
                alert("ã™ã§ã«æ“ä½œä¸­ã§ã™ã€‚");
                return;
            }

            currentOperation = operationType;
            const tokensRaw = document.getElementById('tokenInput').value;
            const channelIdsRaw = document.getElementById('channelIdInput').value;
            const speedSliderValue = parseInt(document.getElementById('speedSlider').value, 10);
            const sendInterval = 10100 - speedSliderValue; // Ensures a minimum interval and inverse relationship (10000ms is slow, 100ms is fast)

            const tokens = tokensRaw.split('\n').map(t => t.trim()).filter(t => t.length > 0);
            const channelIds = channelIdsRaw.split('\n').map(id => id.trim()).filter(id => id.length > 0);
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = ''; // Clear previous status

            if (tokens.length === 0) {
                statusDiv.className = 'error';
                statusDiv.textContent = 'ã‚¨ãƒ©ãƒ¼: Discordãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚';
                return;
            }
            if (channelIds.length === 0) {
                statusDiv.className = 'error';
                statusDiv.textContent = 'ã‚¨ãƒ©ãƒ¼: ãƒãƒ£ãƒ³ãƒãƒ«IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚';
                return;
            }

            isSending = true;
            stopRequested = false;
            statusDiv.className = '';
            statusDiv.textContent = 'æ“ä½œã‚’é–‹å§‹ã—ã¾ã™...';
            document.querySelectorAll('.button-group button').forEach(button => {
                button.disabled = true;
            });
            document.getElementById('stopButton').disabled = false;

            let successfulActions = 0;
            let failedActions = 0;
            let rateLimitedCount = 0;
            let currentTokenIndex = 0;

            const loopCount = (operationType === 'reaction') ? 1 : parseInt(document.getElementById('countSlider').value, 10); // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã¯ãƒãƒ£ãƒ³ãƒãƒ«ã”ã¨ã«æŒ‡å®šæ•°å‡¦ç†ã™ã‚‹ãŸã‚ã€ãƒ«ãƒ¼ãƒ—å›æ•°ã¯1å›

            for (let i = 0; i < loopCount; i++) {
                if (stopRequested) {
                    statusDiv.textContent += `\n\n--- æ“ä½œåœæ­¢ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ä¿¡ã—ã¾ã—ãŸ ---\nåˆè¨ˆè©¦è¡Œæ•°: ${successfulActions + failedActions}\næˆåŠŸ: ${successfulActions}\nå¤±æ•—: ${failedActions}\nãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆé­é‡: ${rateLimitedCount}`;
                    break;
                }

                const currentToken = tokens[currentTokenIndex];

                for (const channelId of channelIds) {
                    if (stopRequested) {
                        statusDiv.textContent += `\n\n--- æ“ä½œåœæ­¢ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ä¿¡ã—ã¾ã—ãŸ ---\nåˆè¨ˆè©¦è¡Œæ•°: ${successfulActions + failedActions}\næˆåŠŸ: ${successfulActions}\nå¤±æ•—: ${failedActions}\nãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆé­é‡: ${rateLimitedCount}`;
                        break;
                    }

                    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
                    if (operationType === 'message') {
                        let baseMessage = document.getElementById('messageInput').value.trim();
                        if (!baseMessage) {
                            statusDiv.className = 'error';
                            statusDiv.textContent = 'ã‚¨ãƒ©ãƒ¼: é€ä¿¡ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚';
                            isSending = false;
                            document.querySelectorAll('.button-group button').forEach(button => {
                                if (button.id !== 'stopButton') {
                                    button.disabled = false;
                                }
                            });
                            document.getElementById('stopButton').disabled = true;
                            return;
                        }

                        const mentionCount = parseInt(document.getElementById('mentionCountSlider').value, 10);
                        const mentionIdsRaw = document.getElementById('mentionIdsInput').value;
                        const mentionIds = mentionIdsRaw.split(',').map(id => id.trim()).filter(id => id.length > 0);
                        const addRandomString = document.getElementById('addRandomStringCheckbox').checked;
                        const randomStringLength = parseInt(document.getElementById('randomStringLengthSlider').value, 10);
                        const enableReply = document.getElementById('enableReplyCheckbox').checked;
                        const replyToMessageId = document.getElementById('replyToMessageIdInput').value.trim();

                        let payload = {
                            "content": baseMessage,
                            "tts": false
                        };

                        if (mentionIds.length > 0 && mentionCount > 0) {
                            const shuffledMentionIds = [...mentionIds].sort(() => 0.5 - Math.random());
                            const selectedMentions = shuffledMentionIds.slice(0, Math.min(mentionCount, mentionIds.length));
                            if (selectedMentions.length > 0) {
                                payload.content += ` ${selectedMentions.map(id => `<@${id}>`).join(' ')}`;
                            }
                        }

                        if (addRandomString) {
                            payload.content += ` ${generateRandomString(randomStringLength)}`;
                        }

                        payload.content += ` ${getRandomEmoji()}`;

                        if (enableReply && replyToMessageId.length > 0) {
                            payload.message_reference = {
                                "channel_id": channelId,
                                "message_id": replyToMessageId,
                            };
                            payload.allowed_mentions = {
                                "parse": ["users", "roles", "everyone"],
                                "replied_user": true
                            };
                        } else if (enableReply && replyToMessageId.length === 0) {
                            statusDiv.className = 'error';
                            statusDiv.textContent = 'ã‚¨ãƒ©ãƒ¼: è¿”ä¿¡ã‚’æœ‰åŠ¹ã«ã™ã‚‹å ´åˆã€è¿”ä¿¡ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚';
                            isSending = false;
                            document.querySelectorAll('.button-group button').forEach(button => {
                                if (button.id !== 'stopButton') {
                                    button.disabled = false;
                                }
                            });
                            document.getElementById('stopButton').disabled = true;
                            return;
                        }

                        const headers = {
                            "Authorization": currentToken,
                            "Content-Type": "application/json",
                        };

                        try {
                            statusDiv.textContent = `[${new Date().toLocaleTimeString()}] (${i + 1}/${loopCount}) ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚’è©¦è¡Œä¸­... (ãƒˆãƒ¼ã‚¯ãƒ³: ${currentTokenIndex + 1}/${tokens.length})`;
                            statusDiv.className = '';

                            const response = await fetch(`https://discord.com/api/v9/channels/${channelId}/messages`, {
                                method: 'POST',
                                headers: headers,
                                body: JSON.stringify(payload)
                            });

                            const responseText = await response.text();
                            let responseJson;
                            try {
                                responseJson = JSON.parse(responseText);
                            } catch (e) {
                                responseJson = { message: responseText || "No JSON response" };
                            }

                            if (response.ok) {
                                successfulActions++;
                                statusDiv.className = 'success';
                                statusDiv.textContent = `[${new Date().toLocaleTimeString()}] [+] (${i + 1}/${loopCount}) ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚(ãƒˆãƒ¼ã‚¯ãƒ³: ${currentTokenIndex + 1}/${tokens.length})\næˆåŠŸ: ${successfulActions}, å¤±æ•—: ${failedActions}, ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ: ${rateLimitedCount}`;
                            } else if (response.status === 429) {
                                rateLimitedCount++;
                                const retryAfter = response.headers.get('Retry-After');
                                statusDiv.className = 'rate-limited';
                                statusDiv.textContent = `[${new Date().toLocaleTimeString()}] [!] (${i + 1}/${loopCount}) ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã®ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆã«é”ã—ã¾ã—ãŸã€‚(ãƒˆãƒ¼ã‚¯ãƒ³: ${currentTokenIndex + 1}/${tokens.length}) ${retryAfter ? retryAfter + 'ç§’å¾Œã«å†è©¦è¡Œã—ã¾ã™ã€‚' : ''}\nã‚¨ãƒ©ãƒ¼è©³ç´°: ${JSON.stringify(responseJson, null, 2)}\næˆåŠŸ: ${successfulActions}, å¤±æ•—: ${failedActions}, ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ: ${rateLimitedCount}`;
                                if (retryAfter) {
                                    await new Promise(resolve => setTimeout(resolve, parseInt(retryAfter, 10) * 1000 + 100));
                                }
                            } else {
                                failedActions++;
                                statusDiv.className = 'error';
                                statusDiv.textContent = `[${new Date().toLocaleTimeString()}] [-] (${i + 1}/${loopCount}) ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã¸ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\nã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${response.status}\nã‚¨ãƒ©ãƒ¼è©³ç´°: ${JSON.stringify(responseJson, null, 2)}\næˆåŠŸ: ${successfulActions}, å¤±æ•—: ${failedActions}, ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ: ${rateLimitedCount}`;
                            }
                        } catch (error) {
                            failedActions++;
                            statusDiv.className = 'error';
                            statusDiv.textContent = `[${new Date().toLocaleTimeString()}] [-] (${i + 1}/${loopCount}) ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}\næˆåŠŸ: ${successfulActions}, å¤±æ•—: ${failedActions}, ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ: ${rateLimitedCount}`;
                            console.error("Fetch error:", error);
                        }
                        await new Promise(resolve => setTimeout(resolve, sendInterval));
                    }
                    // ã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆ
                    else if (operationType === 'thread') {
                        const threadName = document.getElementById('threadNameInput').value.trim();
                        const threadType = document.getElementById('threadTypeSelect').value;

                        if (!threadName) {
                            statusDiv.className = 'error';
                            statusDiv.textContent = 'ã‚¨ãƒ©ãƒ¼: ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½œæˆã™ã‚‹å ´åˆã€ã‚¹ãƒ¬ãƒƒãƒ‰åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚';
                            isSending = false;
                            document.querySelectorAll('.button-group button').forEach(button => {
                                if (button.id !== 'stopButton') {
                                    button.disabled = false;
                                }
                            });
                            document.getElementById('stopButton').disabled = true;
                            return;
                        }

                        const threadPayload = {
                            "name": threadName,
                            "type": threadType === 'public_thread' ? 11 : 12, // 11 for public, 12 for private
                            "auto_archive_duration": 60 // 60 minutes
                        };

                        const headers = {
                            "Authorization": currentToken,
                            "Content-Type": "application/json",
                        };

                        try {
                            statusDiv.textContent = `[${new Date().toLocaleTimeString()}] (${i + 1}/${loopCount}) ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã«ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ä½œæˆä¸­... (ãƒˆãƒ¼ã‚¯ãƒ³: ${currentTokenIndex + 1}/${tokens.length})`;
                            statusDiv.className = '';

                            const response = await fetch(`https://discord.com/api/v9/channels/${channelId}/threads`, {
                                method: 'POST',
                                headers: headers,
                                body: JSON.stringify(threadPayload)
                            });

                            const responseText = await response.text();
                            let responseJson;
                            try {
                                responseJson = JSON.parse(responseText);
                            } catch (e) {
                                responseJson = { message: responseText || "No JSON response" };
                            }

                            if (response.ok) {
                                successfulActions++;
                                statusDiv.className = 'success';
                                statusDiv.textContent = `[${new Date().toLocaleTimeString()}] [+] (${i + 1}/${loopCount}) ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã«ã‚¹ãƒ¬ãƒƒãƒ‰ "${threadName}" ã‚’ä½œæˆã—ã¾ã—ãŸã€‚(ãƒˆãƒ¼ã‚¯ãƒ³: ${currentTokenIndex + 1}/${tokens.length})\næˆåŠŸ: ${successfulActions}, å¤±æ•—: ${failedActions}, ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ: ${rateLimitedCount}`;
                            } else if (response.status === 429) {
                                rateLimitedCount++;
                                const retryAfter = response.headers.get('Retry-After');
                                statusDiv.className = 'rate-limited';
                                statusDiv.textContent = `[${new Date().toLocaleTimeString()}] [!] (${i + 1}/${loopCount}) ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã§ã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆã®ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆã«é”ã—ã¾ã—ãŸã€‚(ãƒˆãƒ¼ã‚¯ãƒ³: ${currentTokenIndex + 1}/${tokens.length}) ${retryAfter ? retryAfter + 'ç§’å¾Œã«å†è©¦è¡Œã—ã¾ã™ã€‚' : ''}\nã‚¨ãƒ©ãƒ¼è©³ç´°: ${JSON.stringify(responseJson, null, 2)}\næˆåŠŸ: ${successfulActions}, å¤±æ•—: ${failedActions}, ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ: ${rateLimitedCount}`;
                                if (retryAfter) {
                                    await new Promise(resolve => setTimeout(resolve, parseInt(retryAfter, 10) * 1000 + 100));
                                }
                            } else {
                                failedActions++;
                                statusDiv.className = 'error';
                                statusDiv.textContent = `[${new Date().toLocaleTimeString()}] [-] (${i + 1}/${loopCount}) ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã§ã®ã‚¹ãƒ¬ãƒƒãƒ‰ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚\nã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${response.status}\nã‚¨ãƒ©ãƒ¼è©³ç´°: ${JSON.stringify(responseJson, null, 2)}\næˆåŠŸ: ${successfulActions}, å¤±æ•—: ${failedActions}, ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ: ${rateLimitedCount}`;
                            }
                        } catch (error) {
                            failedActions++;
                            statusDiv.className = 'error';
                            statusDiv.textContent = `[${new Date().toLocaleTimeString()}] [-] (${i + 1}/${loopCount}) ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}\næˆåŠŸ: ${successfulActions}, å¤±æ•—: ${failedActions}, ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ: ${rateLimitedCount}`;
                            console.error("Thread creation error:", error);
                        }
                        await new Promise(resolve => setTimeout(resolve, sendInterval));
                    }
                    // ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ  (æ—¢å­˜ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«å¯¾ã—ã¦)
                    else if (operationType === 'reaction') {
                        const reactionEmojisRaw = document.getElementById('reactionEmojisInput').value.trim();
                        const reactionEmojis = [...reactionEmojisRaw].map(char => {
                            // çµµæ–‡å­—ãŒã‚«ã‚¹ã‚¿ãƒ çµµæ–‡å­—ï¼ˆä¾‹: custom_emoji:123456789ï¼‰ã®å ´åˆã®å‡¦ç†
                            const customEmojiMatch = char.match(/<:(\w+):(\d+)>/);
                            if (customEmojiMatch) {
                                return `${customEmojiMatch[1]}:${customEmojiMatch[2]}`; // åå‰:ID ã®å½¢å¼
                            }
                            // Unicode çµµæ–‡å­—ã®å ´åˆ
                            return encodeURIComponent(char);
                        });

                        const reactionMessageCount = parseInt(document.getElementById('reactionMessageCountSlider').value, 10);

                        if (reactionEmojis.length === 0) {
                            statusDiv.className = 'error';
                            statusDiv.textContent = 'ã‚¨ãƒ©ãƒ¼: ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ã™ã‚‹å ´åˆã€çµµæ–‡å­—ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚';
                            isSending = false;
                            document.querySelectorAll('.button-group button').forEach(button => {
                                if (button.id !== 'stopButton') {
                                    button.disabled = false;
                                }
                            });
                            document.getElementById('stopButton').disabled = true;
                            return;
                        }

                        // ãƒãƒ£ãƒ³ãƒãƒ«ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾— (æŒ‡å®šã•ã‚ŒãŸæ•°ã ã‘)
                        let messagesToReact = [];
                        try {
                            statusDiv.textContent = `[${new Date().toLocaleTimeString()}] ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã‹ã‚‰æœ€æ–°ã® ${reactionMessageCount} ä»¶ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—ä¸­... (ãƒˆãƒ¼ã‚¯ãƒ³: ${currentTokenIndex + 1}/${tokens.length})`;
                            statusDiv.className = '';

                            const messageResponse = await fetch(`https://discord.com/api/v9/channels/${channelId}/messages?limit=${reactionMessageCount}`, {
                                headers: { "Authorization": currentToken }
                            });
                            const messages = await messageResponse.json();

                            if (messageResponse.ok && messages.length > 0) {
                                messagesToReact = messages;
                                statusDiv.textContent = `[${new Date().toLocaleTimeString()}] ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã‹ã‚‰ ${messages.length} ä»¶ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—ã—ã¾ã—ãŸã€‚`;
                            } else {
                                failedActions++;
                                statusDiv.className = 'error';
                                statusDiv.textContent = `[${new Date().toLocaleTimeString()}] [-] ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã‹ã‚‰ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\nã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${messageResponse.status}\nã‚¨ãƒ©ãƒ¼è©³ç´°: ${JSON.stringify(messages, null, 2)}\næˆåŠŸ: ${successfulActions}, å¤±æ•—: ${failedActions}, ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ: ${rateLimitedCount}`;
                                await new Promise(resolve => setTimeout(resolve, sendInterval));
                                continue; // æ¬¡ã®ãƒãƒ£ãƒ³ãƒãƒ«ã¸
                            }
                        } catch (error) {
                            failedActions++;
                            statusDiv.className = 'error';
                            statusDiv.textContent = `[${new Date().toLocaleTimeString()}] [-] ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å–å¾—ä¸­ã«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}\næˆåŠŸ: ${successfulActions}, å¤±æ•—: ${failedActions}, ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ: ${rateLimitedCount}`;
                            console.error("Fetch messages for reaction error:", error);
                            await new Promise(resolve => setTimeout(resolve, sendInterval));
                            continue; // æ¬¡ã®ãƒãƒ£ãƒ³ãƒãƒ«ã¸
                        }

                        // å„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
                        for (const message of messagesToReact) {
                            if (stopRequested) break;
                            const messageIdToReact = message.id;

                            for (const emoji of reactionEmojis) {
                                if (stopRequested) break;

                                const headers = {
                                    "Authorization": currentToken,
                                };

                                try {
                                    statusDiv.textContent = `[${new Date().toLocaleTimeString()}] ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ${messageIdToReact} ã«ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ ${decodeURIComponent(emoji)} ã‚’è¿½åŠ ä¸­... (ãƒˆãƒ¼ã‚¯ãƒ³: ${currentTokenIndex + 1}/${tokens.length})`;
                                    statusDiv.className = '';

                                    const response = await fetch(`https://discord.com/api/v9/channels/${channelId}/messages/${messageIdToReact}/reactions/${emoji}/@me`, {
                                        method: 'PUT',
                                        headers: headers
                                    });

                                    if (response.status === 204) {
                                        successfulActions++;
                                        statusDiv.className = 'success';
                                        statusDiv.textContent = `[${new Date().toLocaleTimeString()}] [+] ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ${messageIdToReact} ã«ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ ${decodeURIComponent(emoji)} ã‚’è¿½åŠ ã—ã¾ã—ãŸã€‚(ãƒˆãƒ¼ã‚¯ãƒ³: ${currentTokenIndex + 1}/${tokens.length})\næˆåŠŸ: ${successfulActions}, å¤±æ•—: ${failedActions}, ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ: ${rateLimitedCount}`;
                                    } else if (response.status === 429) {
                                        rateLimitedCount++;
                                        const retryAfter = response.headers.get('Retry-After');
                                        statusDiv.className = 'rate-limited';
                                        statusDiv.textContent = `[${new Date().toLocaleTimeString()}] [!] ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ${messageIdToReact} ã§ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³è¿½åŠ ã®ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆã«é”ã—ã¾ã—ãŸã€‚(ãƒˆãƒ¼ã‚¯ãƒ³: ${currentTokenIndex + 1}/${tokens.length}) ${retryAfter ? retryAfter + 'ç§’å¾Œã«å†è©¦è¡Œã—ã¾ã™ã€‚' : ''}\næˆåŠŸ: ${successfulActions}, å¤±æ•—: ${failedActions}, ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ: ${rateLimitedCount}`;
                                        if (retryAfter) {
                                            await new Promise(resolve => setTimeout(resolve, parseInt(retryAfter, 10) * 1000 + 100));
                                        }
                                    } else {
                                        failedActions++;
                                        const responseText = await response.text();
                                        let responseJson;
                                        try {
                                            responseJson = JSON.parse(responseText);
                                        } catch (e) {
                                            responseJson = { message: responseText || "No JSON response" };
                                        }
                                        statusDiv.className = 'error';
                                        statusDiv.textContent = `[${new Date().toLocaleTimeString()}] [-] ãƒãƒ£ãƒ³ãƒãƒ« ${channelId} ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ${messageIdToReact} ã¸ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ ${decodeURIComponent(emoji)} è¿½åŠ ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\nã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${response.status}\nã‚¨ãƒ©ãƒ¼è©³ç´°: ${JSON.stringify(responseJson, null, 2)}\næˆåŠŸ: ${successfulActions}, å¤±æ•—: ${failedActions}, ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ: ${rateLimitedCount}`;
                                    }
                                } catch (error) {
                                    failedActions++;
                                    statusDiv.className = 'error';
                                    statusDiv.textContent = `[${new Date().toLocaleTimeString()}] [-] ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error.message}\næˆåŠŸ: ${successfulActions}, å¤±æ•—: ${failedActions}, ãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆ: ${rateLimitedCount}`;
                                    console.error("Reaction add error:", error);
                                }
                                await new Promise(resolve => setTimeout(resolve, sendInterval));
                            }
                        }
                    }
                }
                currentTokenIndex = (currentTokenIndex + 1) % tokens.length;
            }

            if (!stopRequested) {
                statusDiv.textContent += `\n\n--- æ“ä½œå®Œäº† ---\næˆåŠŸ: ${successfulActions}\nå¤±æ•—: ${failedActions}\nãƒ¬ãƒ¼ãƒˆãƒªãƒŸãƒƒãƒˆé­é‡: ${rateLimitedCount}`;
            }

            isSending = false;
            document.querySelectorAll('.button-group button').forEach(button => {
                if (button.id !== 'stopButton') {
                    button.disabled = false;
                }
            });
            document.getElementById('stopButton').disabled = true;
            currentOperation = null;
        }
    </script>
</body>
</html>
